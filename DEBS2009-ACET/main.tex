\documentclass{sig-alternate}

\begin{document}

\conferenceinfo{DEBS}{2009 Nashville, Tennessee USA}

\title{Partial Actor Continuations}
\subtitle{Efficient and Extensible Request Routing for Event-Driven Architectures}

\numberofauthors{1} 

\author{
\alignauthor
Stefan Plantikow\\
       \affaddr{Zuse Institute Berlin (ZIB)}\\
       \affaddr{Takustrasse 7}\\
       \affaddr{14195 Berlin, Germany}\\
       \email{plantikow@zib.de}
}

\date{1 March 2009}


\maketitle

\begin{abstract}

The request routing logic between the different stages in event-driven architectures is often
distributed over different portions of the source code. This can make it hard to change and
understand the flow of events in the system.

The article presents an approach that allows writing request routing logic as a set of routing
scripts. Requests are executed step-wise according to their script by sending partial continuations
that encapsulate their respective request's current execution state to stages for local processing
and optional forwarding of follow-up continuations. The implementation of a simple domain specific
language for routing scripts for the scala actor library is described and evaluated. The results
show that request routing with partial actor continuations performs equally or better to using a
separate stage for request routing logic for scripts of at least 3 sequential steps. 

\end{abstract}

\category{H.2.4}{Information Systems}{Systems}[Concurrency]         
\category{D.1.3}{Software}{Programming Techniques}[Concurrent Programming]         
\category{D.3.3}{Programming Languages}{Language Constructs and Features}[Concurrency]
\category{D.2.11}{Software Engineering}{Distribution, Maintenance, and Enhancement}[Extensibility]

\keywords{Request Routing, Event-Driven Architecture, Partial Continuation, Actor Model, Scala}


\section{Introduction}             

Using a staged, event-driven architecture is an approach to the design of server software that can 
provide high degrees of concurrency and throughput.  This is achieved by structuring the software as
a set of stages that communicate exclusively via event queues and by optionally performing admission 
control on each queue.  

// TODO Examples of staged architectures are ...
// TODO XtreemFS example

Depite their benefits, event-driven architectures can lead to a distribution of application logic
over different stages. The implementation of each stage usually resides in a different portions of
the source code and therefore the dynamic routing of requests through different stages is not
described by a single source location.

This reduces the understandability of the system and in turn makes it harder to modify the request
routing logic. Additionally, it makes it difficult to add new request types without changing the
source code of existing stages and redeploying the system.

- Problem deScription\\

- Article overview\\
                                
                         
\section{Preliminaries}

-Actor Model \\

Scala is a multiparadigm programming language for the Java virtual machine that fuses objectoriented
and functional techniques. Since Scala is statically typed, its compiler produces considerably fast
code. At the same time, the languages includes features that are often only found in dynamically
typed languages for the JVM. Sofleuse uses some of those, like CPS-transform in
generator-expressions, anonymous functions, multiple inheritance and self-types.

Additionally, the Scala standard library includes a rich set of concurrency primitives that
implement different process calculi, like the join-calculus, the pi-calculus, and the actor model.
Actors are available in two flavours: \textbf{react}-actors who get scheduled by the actor library
piece-wise to different threads, and \textbf{receive}-actors that live in their on thread. Since
stage-based architecture associate one thread with each stage, for the purposes of this article, 
only \textbf{receive}-based actors are considered.



\section{Request Routing}

The application logic of event-driven architectures can be split into two categories. First,
processing logic, is the part of application logic that necessarily must be executed at a specific
stage in order to access resources or state that are only available locally. Second, the request
routing logic describes how a given incoming request is handled by executing processing logic at
many stages in some order. 

Often, processing logic is contained implicitely in the event handling of single stages and the
follow-up events created by them. It is this implicit containment that can make systems difficult to
understand and modify.

Additionally, request routing logic may be stateful, i.e. the result of executing processing logic
at some stage may determine how and at which stages request handling needs to be continued. This
places further burdens on the implementation of single stages, as incoming- and outgoing events need
to be amended with the necessary state data, although it might be completely independent from the
intended purpose of the stage.

To give an example, imagine a simple system for launching satellites into space. Incoming
reqeuests are amended with authentication information in the first stage. In the second stage, this
information is then used to authorize the request and eventually launch the rocket. Only after the
satellite has begun to operate, some third stage (i.e. the press office) is informed.  Now, imagine
that the initial request needs to be amended with extra information (name and owner of satellite)
for the press office.  Passing this information down requires modifying the events to and from
the rocket launching stage with fields for the additional payload, although this extra information
is of no importance to launching the rocket.

This intertwining of processing and request routing logic is a case of insufficient separation of
concerns, calling for a different way to describe both types of application logic.  Next, two 
different approaches that address this issue are described.


\subsection{Ping-Pong Approach}

A straightforward way to deal with this problem is to transfer the execution of the request routing
logic to a separate stage. Requests enter the system as separate events at such a routing stage.
This stage then continously forwards events to some stage, waits for a reply, and upon receipt,
decides how to continue based on this and previous reply-events for the request. In the following,
this will be called the ping-pong-approach.

While this approach allows to write the event flow portion of the application logic in a single
stage, it has two disadvantages: First, it requires the creation of additional stages and the
associated computational overhead. Second, and more importantly, it results in extra messages
between request routing and regular processing stages.

The ping-pong approach centralizes routing logic in a single place by introducing an additional
stage. This can be understood as the consolidation of a control flow that otherwise would be
scattered throughout the source code. Additionally, for each request, the routing stage stores
intermediate results and associated state for reuse by later events, as well as provides the ability
to pause a request's control flow while waiting for the execution of processing logic by some other
stage.



\subsection{Partial Actor Continuations}

Extracting routing logic requires a mechanism for \emph{pausable, stateful control-flow}.
Introducing an extra stage is just one way to achieve this. Other possible techniques are the use of
coroutines or continuations the latter on which this article concentrates.
          

// google arbitrary often

// TODO: More on Continuations (?)

The continuation of a computation describes the part of a computation that yet needs to be computed.
Some programming languages, especially the scheme-dialect of lisp, provide means for explicitely
capturing the continuation at runtime and by this allow it to be executed arbitrary often.  This
can be used to implement new control structures inside the programming language.  

                                
// Parameterization

This ability may be used to create pausable, stateful control-flow: Each stage only processes
messages that actually are anonymous functions that represent the current continuation of some
request. Such incoming continuations are executed by calling them with the executing stage as their
sole argument. Through this means, request continuations gain access to the functionality of local
stages.

When the execution of a request continuation at a stage is about to finish, the follow-up 
continuation may be captured in a last step.  This follow-up continuation is then simply sent
to the next stage where request handling continues.  

This approach does not require any intermediate stages for the execution of the request logic and
through this avoids the additional messages of the ping-pong approach. It is also stateful, since
continuations contain all visible state of their stack frame at capture time. On the downside, it
requires some overhead for continuation capturing. The impact of these different properties will be
shown in the evaluation section.

                         



\section{Sofleuse: A Request Routing DSL}

Now a framework for using partial actor continuations, Sofleuse, is presented. Sofleuse has been
implemented in the Scala programming language using the scala actor's library. Sofleuse provides a
domain specific language (DSL) for writing routing scripts that execute over a set of locally
running actors.

Routing script are implemented by subclassing the class Play and overriding the apply method. Play
instances are provided with a set of DSL-commands for writing scripts. Commands provide the ability
to structure scripts as a sequence of blocks that are each executed at different stages. To capture
continuations, commands are chained by using scala's CPS-transforming for-generator-expressions
(explained below). The following command set is provided:


\begin{itemize}                                   
	\item \textbf{\emph{v} <- remember(\emph{value})} Bind \emph{value} to \emph{v} for reuse by
	later routing decisions of the script
	\item \textbf{\emph{v} <- compute(\emph{thunk})} Compute \emph{thunk} at the current local stage.  
	The return value is bound to \emph{v} and may be reused in later routing decisions of the script
	\item \textbf{\emph{v} <- computeWith(\emph{o})(\emph{thunk})} Like \textbf{compute(\emph{thunk})} 
	but \emph{thunk} takes \emph{o} as its first argument
	\item \textbf{\emph{s} <- goto(\emph{stage})} Continue execution at stage \emph{stage} and 
	return a reference \emph{s} for gainining access to the local processing logic of \emph{stage} 
	(usually \emph{stage} itself)
	\item \textbf{\emph{s} <- jump(\emph{thunk})} Execute thunk at the current (active) stage in 
	order to determine the next stage for script execution.	Return a suitable reference \emph{s} to 
	gain access to the local processing logic of that stage
	\item \textbf{\emph{t} <- cast[\emph{T}](\emph{stage})} Like \textbf{goto(\emph{stage})} but 
	cast the result of \textbf{goto(\emph{stage})} to type \emph{T}   
	\item \textbf{yield(result)} The yield statement of the for-expression may optionally be used to 
	return a result to the initial caller of the script                           	
	\item \textbf{endOfPlay} Syntactically denote the end of a routing script that does not return
	 a value to its caller.
\end{itemize}                                                                                                             
                                                                 
The class Play places an upper bound on the type of actor-stages over which the routing script
commands operate. Routing scripts can also be written as simple for-expressions without using class
Play. This may lead to more typecasts through the use of the untyped DSL-commands provided as
additional utility functions by Sofleuse. Simple routing scripts based on simple for-expressions may
be run using two additional commands of the DSL:

\begin{itemize}
    \item \textbf{run(\emph{forExpr})} Run \emph{forExpr} and wait until its execution yields a result (blocks current actor)
	\item \textbf{asyncRun(\emph{forExpr})} Runs \emph{forExpr} without waiting for a result (non-blocking)
\end{itemize}	

As an example, consider the execution of a simple RPC call~(Fig.~\ref{fig:rpc}).  The call is wrapped
as a function that initially creates a new script based on a simple for-expression. The script
itself first transfers the execution to the stage for the rpc using \textbf{goto}. Then, the actual 
rpc is executed at that stage using \textbf{compute}, and finally a return value is yielded.  
To actually execute this routing script for-expression, it is started with \textbf{run}.

\begin{figure}
\centering    
\begin{tabular}{l}           
$\textbf{def}\ $rpc$(\emph{initialStage}, \emph{input})\ =\ \{$\\	
\hspace{2ex} $\textbf{val}\ \emph{request}\ =\ \textbf{for} ($\\
\hspace{6ex} $\emph{stageRep}\ <-\ $goto$(\emph{initialStage})$\\
\hspace{6ex} $\emph{result}\ <-\ $compute$\ \{\ stageRep.$compute$(\emph{input})\ \}$\\
\hspace{2ex} $)\ \textbf{yield}\ result$\\
\hspace{2ex} $\textbf{return}\ $run$(\emph{request})$\\   
$\}$\\
\end{tabular}
\caption{Simple RPC in Sofleuse\label{fig:rpc}}
\end{figure}

Currently, Sofleuse does not yet support exception handling across stage boundaries.
                                                                                

\section{Implementation}
            
To implement the continuation-passing approach to extracting request routing logic, several 
subproblems had to be solved.

\subsection{Actors that execute arbitrary code} 

First, it is necessary that actors may be instructed externally to execute thunks of arbitrary
control flow. For this, Sofleuse provides the trait StageActor whose main loop listens for messages
consisting of one-argument anonymous lambda-functions. When such a function is received, it is
executed by passing a reference to the StageActor itself as a representation of access to local
processing logic as its first argument.

Additionally, for advanced uses, Sofleuse supports another type of actor, whose processing logic
representation (called Prop) can be replaced at runtime by routing scripts.


\subsection{Passing Continuations}

- From lambdas to fors\\
- Explain CPS\\
- Explain CPS in scala\\
                                                                           
\subsection{Continuation Access}

- Nice littel extension\\

\section{Evaluation}

// Describe settting

// Present results

// Discuss in detail esp w regard to actor library


\section{Related Work}

// Let's see...

\section{Summary}
                  
// Fazit

// Interesting applications

\section{Acknowledgments}

\bibliographystyle{abbrv}
%\bibliography{sigproc}  

\end{document}
